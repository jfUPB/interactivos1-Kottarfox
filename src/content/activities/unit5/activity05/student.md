En esta unidad trabajamos con un protocolo binario y antes con ASCII, y la verdad es que hay varias diferencias. En cuanto a eficiencia, el binario es más eficiente porque manda menos datos, o sea no hay que mandar letras ni comas ni nada, solo los bytes que hacen falta. Con ASCII se entiende mejor pero es más pesado. Por ejemplo, antes en ASCII mandaba algo tipo "X:1023,Y:-43" y eso ocupaba un montón, pero con binario es solo como 8 bytes. Eso lo hace también más rápido, porque se transmiten menos cosas. Sin embargo, es más difícil de leer o debugear, o sea no podés ver los valores directo en consola, se ve como números raros. También el binario usa menos recursos, sobre todo memoria, porque no estás guardando strings, solo bytes. Pero en facilidad gana ASCII, porque todo es más entendible a simple vista.

Para que todo eso del protocolo binario funcione, fue necesario meter un "framing". O sea, sin eso no sabés dónde empieza un paquete de datos. Si el micro:bit manda datos sin una marca, es muy fácil que se desfasen, y después no hay forma de saber cuál byte es qué. El framing básicamente es poner un byte especial al inicio del paquete, como una bandera. En nuestro caso usamos 0xAA, que es como decirle al programa "aquí empieza un paquete, contá desde acá". Si no hay eso, o si está corrido, todo se rompe.

El carácter de sincronización es ese byte especial que usamos para marcar el inicio del paquete. Es como un punto de referencia. En binario no hay separadores como en texto, así que esto es como un ancla. El checksum, por su parte, es otra cosa que se suma al paquete. Es una suma de los otros datos, y sirve para comprobar que el paquete llegó bien. Si se manda algo y lo que recibís no cuadra con ese número, entonces se detecta que hubo un error. Por ejemplo, si el checksum calculado no es igual al que vino en el paquete, el código lo ignora.

En la función readSerialData() hay un momento donde usamos .concat(). Eso es porque los datos llegan por partes, y hay que irlos juntando en el buffer. Por eso se usa serialBuffer = serialBuffer.concat(newData);, así se van acumulando los bytes que llegan. Luego, hay un while que solo entra si el buffer tiene al menos 8 bytes, porque ese es el tamaño del paquete que esperamos. Si hay menos, no tiene sentido procesar nada, porque estaría incompleto. Por eso hay un break que corta el bucle si no hay suficientes bytes todavía.

Dentro del bucle, se revisa si el primer byte es 0xAA. Eso es porque ese byte marca el inicio del paquete. Si no lo es, significa que el buffer está desfasado, así que hacemos serialBuffer.shift() para tirar ese primer byte y ver el siguiente. Luego, con continue se vuelve al principio del while, para seguir buscando el inicio correcto. Cuando encontramos 0xAA, hacemos un slice(0,8) para copiar los 8 bytes del paquete sin tocarlos, y después un splice(0,8) para sacarlos del buffer, o sea los procesamos y los eliminamos para que no se repitan.

Después viene una parte donde usamos .reduce() para calcular el checksum. Ahí se suman todos los bytes del paquete, y se hace % 256 para que quede como un byte (porque los bytes van de 0 a 255). Si ese checksum calculado no coincide con el que vino en el paquete, el código muestra un error y hace continue para pasar al siguiente paquete. Eso evita usar datos malos.

También usamos un DataView para poder interpretar los bytes correctamente. Primero convertimos los datos a un Uint8Array, y de ahí a un ArrayBuffer. Con DataView podemos leer esos bytes como getInt16() o getUint8(), o sea enteros de 2 bytes o de 1. Esto es necesario porque si tratamos de leer los datos directamente como están en el array, no los podemos interpretar bien. Por ejemplo, para las coordenadas usamos getInt16() en la posición 0 y 2, y para los botones usamos getUint8() en las posiciones 4 y 5. Eso ya nos da los valores que necesitamos para mover cosas en la pantalla.

En resumen, todo este proceso de leer datos binarios fue más complejo que con ASCII, pero también más eficiente y rápido. Hay que tener más cuidado con el orden de los bytes, el framing, y validar con checksum, pero una vez que todo eso está, el programa funciona mucho mejor.
